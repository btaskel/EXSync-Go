# 概述：
## 通讯：

**端口设置：**

* 客户端：
* 指令发送端口：`[random]`
* 数据传输端口：`[random]`


* 服务端：
* 数据传输端口：`[server_port]`
* 指令接收端口：`[server_port + 1]`

* webui：
* 端口：`默认8080`

### 大致通讯模型：

    主机A                               主机B

    client(主动控制方—连接对方server)      client (主动控制方—连接对方server)
    server(被动控制方-监听所有client)      server (被动控制方-监听所有client)

    Server: CommandSocket持续接收来自Client的指令。
            DataSocket持续接收来自Client的数据并转交给TimeChannel，同时可以主动发送到Client-DataSocket数据。
    Client: CommandSocket主动向Server-CommandSocket发起指令。
            DataSocket主动向Server-DataSocket发送数据，同时可以接收来自Server-DataSocket的数据并转交给TimeChannel。

    主动&被动操作: 只有A创建Client并与B的Server连接才能与B主动发起操作，B亦然。
    数据接收隔离: 每一个Client与Server连接后隔离建立TimeChannel。
    服务连接建立: Server有且仅有一个实例存在, Client无限制。

### 核心权限分级：

1. guest(主要用于验证是否为用户)：0
2. user(主要用于安全范围内的文件操作)：10
3. admin(使用shell远程控制主机等全部权限)：20

**客户端发送至服务端指令套接字：

指令以 随机8字节的Mark 开头，并且连接字典来传递参数。
在后续的异步发送文件中，每一条指令的发送会自动加上 8个字节的mark 标识。

    更改指令格式为：
    [8bytesMark]{
                    "command": "data"/"comm", # 命令类型(数据类型/命令类型)
                    "type": "file",         # 操作类型(具体操作方式)
                    "method": "get",        # 操作方法(get/post 获取与提交)
                    "data": {               # 参数数据(具体参数)
                        "a": 1
                        ....
                        "stat": "errorText" # 远程返回/发送的错误信息
                    }
                }

### 服务端答复至客户端指令套接字：

更改使用TimeChannel实现数据的总体接收与解密。
每一个Client与Server连接后隔离建立TimeChannel。

### 硬盘缓冲：

为了减少写入次数, exsync会创建内存缓存用于缓存已接收到的数据, 以此来保护硬盘寿命。


## 同步：

### 使用相对路径进行文件同步：

每个主机的同步空间绝对路径没有必要保持一致。

    1.当主机A发送文件同步请求，会首先在索引文件中寻找当前文件信息。
    2.主机B接收文件时会根据同步空间名称来推断对方发送的文件路径。
        
    A. 发送参数<SpaceName> ./a/b/c.txt。
    B. 查询该文件在SpaceName的路径信息，与 ./a/b/c.txt 相连接得到文件绝对路径。

### 文件同步池：

在与某一台主机的同步空间进行同步时，为了尽可能地进行负载均衡, exsync会使用文件池动态调整文件拉取的目标主机。

当exsync对一个同步空间进行同步操作时, 会先拉取与之连接的N个主机的同一同步空间的文件索引。
之后将需要同步的文件存储至一个队列, 在理想情况下这个队列中的文件会按块均匀地分散到N个主机,
并从中请求相应数据的传输。如果请求某一主机失败或者遇到其它错误，将会从其它主机拉取，这个过
程会尽可能地保持每个主机相同的压力。

### 双方文件同步判断

exsync依赖于系统时间进行同步; 作用于双方的同一同步空间, 现有文件A与文件B, 且文件名相同。

    假设:
        文件A的修改时间 > 文件B的修改时间 -> 由A同步至B
        文件A的修改时间 = 文件B的修改时间 -> 无操作
        文件A的修改时间 < 文件B的修改时间 -> 由B同步至A

在对某一同步空间进行同步时, 会首先搜索当前连接列表的远程主机是否有该同步空间, 如果存在则会拉取对方的同步空间索引哈希值到本地进行对比。
假设哈希值一致则会进行拉取对比。如果该网络下只有两台主机启用了exsync服务, 只会进行`双端同步`与`监控同步`。

* **双端同步**：

1. 当前文件大小总量 < 文件大小总量传输阈值 **并且** 文件总量 < 文件总量传输阈值 则启用此同步模式。

2. 在该模式下exsync每次会对单个主机进行拉取同步, 相对于多端同步在文件量较少的情况下能够节省一些性能开销。

* **多端同步**：

1. 当前文件大小总量 >= 文件大小总量传输阈值 **或者** 文件总量 >= 文件总量传输阈值则启用此同步模式。

2. 在该模式下exsync会得到每一个远程主机的同步空间需要同步拉取的文件, 并将大于等于2个需要同步的同步空间文件整合到一个文件同步池中去, 文件同步池中的文件相对于其它文件暂时不会进行同步。

3. exsync会根据需要同步的主机发起数量同样的同步操作(并非指的文件批量传输数量), 假设在这些同步操作中出现已完成传输数据大小不同, 文件同步池会及时分配给相应的同步操作新的传输内容。

4. exsync如果发现文件同步池分配给同步操作的传输内容抛出错误, 则会将该传输分配至其它的同步空间进行传输。 


* **监控同步**：

1. 监控同步会在`双端同步`或`多端同步`开始前或完成后持续运行。


